Lecture 1:
Fetch for the auth API::
In order to integrate the auth API endpoints from the server with the frontend React
components, we will add methods for fetching sign-in and sign-out API endpoints in
the client/auth/api-auth.js file.

Sign-in::
--The signin method will take user sign-in data from the view component, then use
fetch to make a POST call to verify the user with the backend.
---The component invoking this method
needs to handle the response appropriately, such as storing the received JWT locally
so it can be used when making calls to other protected API routes from the frontend.

Sign-Out::
--signout uses fetch to make a GET
call to the signout API endpoint on the server.

***With these API fetch methods added, the React frontend has complete access to the
endpoints we made available in the backend.

Lecture 2:
Adding auth in the frontend:
---implementing authentication with JWT
relinquishes responsibility to the client-side to manage and store user auth state. To
this end, we need to write code that will allow the client-side to store the JWT that's
received from the server on successful sign-in, make it available when accessing
protected routes, delete or invalidate the token when the user signs out, and also
restrict access to views and components on the frontend based on the user auth state

--Using examples of the auth workflow from the React Router documentation, in the
following sections, we will write helper methods to manage the auth state across the
components, and also use a custom PrivateRoute component to add protected
routes to the frontend of the MERN skeleton application

Lecture 3:
Managing auth state::
--To manage auth state in the frontend of the application, the frontend needs to be able
to store, retrieve, and delete the auth credentials that are received from the server on
successful user sign in.

--we will use the browser's
sessionsStorage as the storage option to store the JWT auth credentials.

NB:
Alternatively, you can use localStorage instead of
sessionStorage to store the JWT credentials. With
sessionStorage, the user auth state will only be remembered in
the current window tab. With localStorage, the user auth state
will be remembered across tabs in a browser.

Saving credentials::
--It stores the credentials in sessionStorage after
ensuring window is defined, in other words ensuring this code is running in a
browser and hence has access to sessionStorage.

--it executes the callback
function that is passed in. This callback will allow the component – in our case, the
component where sign-in is called – to define actions that should take place after
successfully signing in and storing credentials. Next, we will discuss the method that
lets us access these stored credentials.

Retrieving Credentials:
--we will need to retrieve the stored credentials to check if
the current user is signed in.

Deleting credentials::
--When a user successfully signs out from the application, we want to clear the stored
JWT credentials from sessionStorage

Lecture 4:
The PrivateRoute component::
--declaring protected routes for the frontend to restrict view access based on user auth

Lecture 5:
Completing the User frontend::
--here we will complete the view, create modify user data stored in the db wit resp to auth restrictions

**Users: To fetch and list all users from the database to the view
**Signup: To display a form that allows new users to sign up
**Signin: To display a form that allows existing users to sign in
**Profile: To display details for a specific user after retrieving from the
database
*EditProfile: To display details for a specific user and allow authorized
user to update these details
**DeleteUser: To allow an authorized user to delete their account from the
application
**Menu: To add a common navigation bar to each view in the application

The Users component::
--that have been fetched from the database and links each name to the user profile. The
following component can be viewed by any visitor to the application and will render
at the '/users' route:

--The argument that's passed to useState
is the initial value of this variable – in other words, the initial state. Invoking
useState returns the current state and a function that updates the state value, which
is similar to this.setState in a class definition.
With the users state initialized, next, we will use another built-in React hook named
useEffect to fetch a list of users from the backend and update the users value in
the state.

--To add this Users component to the React application, we need to update the
MainRouter component with a Route that renders this component at the
'/users' path.

Lecture 6:
The Signup component::
--client/user/Signup.js presents a form with name,
email, and password fields to the user for sign-up at the '/signup' path, as
displayed in the following screenshot:

Lecture 7:
The Signin component::
--this is similar to the signup component
--The key difference is
in the implementation of redirection after a successful sign-in and storing the received
JWT credentials
--For redirection, we will use the Redirect component from React Router. First,
initialize a redirectToReferrer value to false in the state with the other fields:

Lecture 8:
The Profile component::
--The Profile component in client/user/Profile.js shows a single user's
information in the view at the '/user/:userId' path, where the userId parameter
represents the ID of the specific user. The completed Profile will display user
details, and also conditionally show edit/delete options.

--This profile information can be fetched from the server if the user is signed in. To
verify this, the component has to provide the JWT credential to the read fetch call;
otherwise, the user should be redirected to the Sign In view.

--Once the server responds, either the state is updated with the user information or the
view is redirected to the Sign In view if the current user is not authenticated

--However, if the user that's currently signed in is viewing their own profile, they will
be able to see edit and delete options in the Profile component, as shown in the
following screenshot:

Lecture 9:
The EditProfile component:
--here the authorized user can edit their won profile information in a form similar to signup form

--Upon loading at '/user/edit/:userId', the component will fetch the user's
information with their ID after verifying JWT for auth, and then load the form with
the received user information. The form will allow the user to edit and submit only
the changed information to the update fetch call, and, on successful update, redirect
the user to the Profile view with updated information.

Lecture 10:
The DeleteUser component::
--s is basically a button
that we will add to the Profile view that, when clicked, opens a Dialog component
asking the user to confirm the delete action.

Lecture 11:
The Menu component::
--The Menu component will function as a navigation bar across the frontend application
by providing links to all the available views, and also by indicating the user's current
location in the application.

--The remaining links such as SIGN IN, SIGN UP, MY PROFILE, and SIGN OUT will
show up on the Menu based on whether the user is signed in or not.

--To have the Menu navigation bar present in all the views, we need to add it to the
MainRouter before all the other routes, and outside the Switch component.

Lecture 12:
Implementing basic server-side rendering:
---Currently, when the React Router routes or pathnames are directly entered in the
browser address bar or when a view that is not at the root path is refreshed, the URL
does not work. This happens because the server does not recognize the React Router
routes we defined in the frontend. We have to implement basic server-side rendering
on the backend so that the server is able to respond when it receives a request to a
frontend route.

--To render the relevant React components properly when the server receives requests
to the frontend routes, we need to initially generate the React components on the
server-side with regard to the React Router and Material-UI components, before the
client-side JS is ready to take over the rendering.

***The basic idea behind server-side rendering React apps is to use the
renderToString method from react-dom to convert the root React component into
a markup string. Then, we can attach it to the template that the server renders when it
receives a request.***

Lecture 13:
Modules for server-side rendering:
import following to express.js file
****React modules: The following modules are required to render the React
components and use renderToString:
    import React from 'react'
    import ReactDOMServer from 'react-dom/server'
****Router modules: StaticRouter is a stateless router that takes the
requested URL to match with the frontend route which was declared in the
MainRouter component. The MainRouter is the root component in our
frontend.
    import StaticRouter from 'react-router-dom/StaticRouter'
    import MainRouter from './../client/MainRouter'
****Material-UI modules and the custom theme: The following modules will
help generate the CSS styles for the frontend components based on the
stylings and Material-UI theme that are used on the frontend:
    import { ServerStyleSheets, ThemeProvider } from '@materialui/
styles'
    import theme from './../client/theme'

Lecture 15:
Generating CSS and markup::
--To generate the CSS and markup representing the React frontend views on the serverside,
we will use Material-UI's ServerStyleSheets and React's renderToString.
--On every request received by the Express app, we will create a new
ServerStyleSheets instance. Then, we will render the relevant React tree with the
server-side collector in a call to renderToString, which ultimately returns the
associated markup or HTML string version of the React view that is to be shown to
the user in response to the requested URL.

Lecture 16:
Sending a template with markup and CSS::
---Once the markup has been generated, we need to check if there was a redirect
rendered in the component to be sent in the markup. If there was no redirect, then we
get the CSS string from sheets using sheets.toString, and, in the response, we
send the Template back with the markup and CSS injected, as shown in the
following code.

--An example of a case where redirect is rendered in the component is when we're
trying to access a PrivateRoute via a server-side render. As the server-side cannot
access the auth token from the browser's sessionStorage, the redirect in
PrivateRoute will render. The context.url value , in this case, will have the
'/signin' route, and hence, instead of trying to render the PrivateRoute
component, it will redirect to the '/signin' route.

Lecture 17:
Updating template.js
--The markup and CSS that we generated on the server must be added to the
template.js HTML code for it to be loaded when the server renders the template.

Updating App.js:
--Once the code that's been rendered on the server-side reaches the browser and the
frontend script takes over, we need to remove the server-side injected CSS when the
root React component mounts, using the useEffect hook.

Hydrate instead of render::
--Now that the React components will be rendered on the server-side, we can update
the main.js code so that it uses ReactDOM.hydrate() instead of
ReactDOM.render():