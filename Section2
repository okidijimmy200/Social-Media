Lecture 1:
Serving an HTML template at a root URL:
--In the template.js file, add a JS function that returns a simple HTML document
that will render Hello World on the browser screen.

--To serve this template at the root URL, update the express.js file to import this
template and send it in the response to a GET request for the '/' route.

--run the file on browser, it prints out hello World

Lecture 2:
Implementing the user model:
--We will implement the user model in the server/models/user.model.js file and
use Mongoose to define the schema with the necessary user data fields.

User schema definition:
--The user schema definition object that's needed to generate the new Mongoose
schema will declare all user data fields and associated properties ie name, email, created-at, last-updated-at

Password for auth::
--The password field is very crucial for providing secure user authentication in any
application, and each user password needs to be encrypted, validated, and
authenticated securely as a part of the user model.

Handling the password string as a virtual field::
--The password string that's provided by the user is not stored directly in the user
document. Instead, it is handled as a virtual field.

Lecture 3:
Encryption and authentication::
--The encryption logic and salt generation logic, which are used to generate the
hashed_password and salt values representing the password value, are defined as
UserSchema methods.

--Hashing algorithms generate the same hash for the same input
value. But to ensure two users don't end up with the same hashed
password if they happen to use the same password text, we pair
each password with a unique salt value before generating the
hashed password for each user. This will also make it difficult to
guess the hashing algorithm being used because the same user input
is seemingly generating different hashes.

Lecture 4:
Password Field validtion:
--To add validation constraints to the actual password string that's selected by the end
user, we need to add custom validation logic and associate it with the
hashed_password field in the schema.
--this will ensure tht the length of the password is atleast 6 characters long for new users or  for users 
who are updating their passwords.

Lecture 5:
Mongoose error handling:
--we will define a helper method tht returns a relevant error message tht can be propagated
in the request-response cycle incase an error is made.
--We will add the getErrorMessage helper method to the
server/helpers/dbErrorHandler.js file.

Lecture 6:
Adding user CRUD APIs::
----To implement these API working endpoints, we will 
****write Express routes and the corresponding 
***controller callback functions that should be executed when HTTP
requests come in for these declared routes. In this section, we will look at how these
endpoints work without any auth restrictions.

--creating the routes
server/routes/user.routes.js,

userRoutes
--The user routes that are defined in the user.routes.js file will use
express.Router() to define route paths with the relevant HTTP methods and
assign the corresponding controller function that should be called when these
requests are received by the server.

--the following routes will be implemented
    /api/users for the following:
        Listing users with GET
        Creating a new user with POST
    /api/users/:userId for the following:
        Fetching a user with GET
        Updating a user with PUT
        Deleting a user with DELETE

User Controller:
-The server/controllers/user.controller.js file will contain definitions of the
controller methods that were used in the preceding user route declarations as
callbacks to be executed when a route request is received by the server.

--lodash is a JavaScript library that provides utility functions for
common programming tasks, including the manipulation of arrays
and objects. To install lodash, run 
*********yarn add lodash***********

Lecture 7:
Creting a new user::
-Async/await is an addition to ES8 that allows us to write
asynchronous JavaScript code in a seemingly sequential or
synchronous manner. For controller functions that handle
asynchronous behavior such as accessing the database, we will use
the async/await syntax to implement them.

Lecture 8:
Listing all Users:
--The list controller function finds all the users from the database, populates only the
name, email, created, and updated fields in the resulting user list, and then returns
this list of users as JSON objects in an array to the requesting client

Lecture 9:
Loading a user by ID to read, update, or delete::
--All three API endpoints for read, update, and delete require a user to be loaded from
the database based on the user ID of the user being accessed

Reading::
--The read function retrieves the user details from req.profile and removes
sensitive information, such as the hashed_password and salt values, before
sending the user object in the response to the requesting client

Updating:
--When the Express app gets a PUT request at '/api/users/:userId', similar to
read, it loads the user with the :userId parameter value before executing the
update controller function.

--The update function retrieves the user details from req.profile and then uses the
lodash module to extend and merge the changes that came in the request body to
update the user data. Before saving this updated user to the database, the updated
field is populated with the current date to reflect the last updated timestamp. Upon
successfully saving this update, the updated user object is cleaned by removing
sensitive data, such as hashed_password and salt, before sending the user object in
the response to the requesting client

deleting :
--When the Express app gets a DELETE request at '/api/users/:userId', similar to
read and update, it loads the user by ID and then the remove controller function is
executed

--The remove function retrieves the user from req.profile and uses the remove()
query to delete the user from the database. On successful deletion, the requesting
client is returned the deleted user object in the response.

Lecture 10:
Integrating user auth and protected routes
--To restrict access to user operations such as user profile view, user update, and user
delete, we will first implement sign-in authentication with JWT, then use it to protect
and authorize the read, update, and delete routes.

--we will use the auth.routes.js

--The auth routes are as follows:
'/auth/signin': POST request to authenticate the user with their email
and password
'/auth/signout': GET request to clear the cookie containing a JWT that
was set on the response object after sign-in


-we create the authCtrl file

Signin:
--Then, the signed JWT is returned to the authenticated client, along with the user's
details. Optionally, we can also set the token to a cookie in the response object so that
it is available to the client-side if cookies are the chosen form of JWT storage. On the
client-side, this token must be attached as an Authorization header when
requesting protected routes from the server. To sign-out a user, the client-side can
simply delete this token depending on how it is being stored. In the next section, we
will learn how to use a signout

signout:
signout function clears the response cookie containing the signed JWT
--With JWT, user state storage is the client's responsibility, and there are multiple
options for client-side storage besides cookies. On signout, the client needs to delete
the token on the client-side to establish that the user is no longer authenticated. On
the server-side, we can use and verify the token that's generated at sign-in to protect
routes that should not be accessed without valid authentication. In the next section,
we will learn how to implement these protected routes using JWT.

Protecting routes with express-JWT::
--To protect access to the read, update, and delete routes, the server will need to check
that the requesting client is actually an authenticated and authorized user.

--To check whether the requesting user is signed in and has a valid JWT when a
protected route is accessed, we will use the express-jwt module.

Protecting user routes::
we implement protexcting of user routes to enable authentication and authorization of user data

Requiring signin:
--The requireSignin method in auth.controller.js uses express-jwt to verify
that the incoming request has a valid JWT in the Authorization header.

--If the token
is valid, it appends the verified user's ID in an 'auth' key to the request object;
otherwise, it throws an authentication error.

Authorizing signed in users;
--For some of the protected routes, such as update and delete, on top of checking for
authentication we also want to make sure the requesting user is only updating or
deleting their own user information.

Lecture 11:
Auth error handling for express-jwt::
--To handle auth-related errors thrown by express-jwt when it tries to validate JWT
tokens in incoming requests, we need to add the following error-catching code to the
Express app configuration in the express.js file

Checking the standalone backend::
--there are multiple ways of checking whether our backend code is functioning ie using postman

Creating a new user:





